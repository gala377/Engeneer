poprawki

get_next_token_with_blank

json.org lexowanie floata

tabela ascii etx zamiast '\0'

tablica ascii na funkcje zamiast mapy

//
do zapytania

errors for lexer
postfixes
prefixes


//
DO ZROBIENIA


ast error handling <- teraz mamy po prostu throw

lexer error handling
parser testy
ast testy

struct keyword zostawiamy?

lexowanie komentarzy
lexowanie floatów
lexowanie escapowania w stringach ?


nie pozwalanie na 2 metody o takiej samej nazwie w obrębie struktury
nie pozwalanie na 2 zmienne o takiej samej nazwie w obrębie struktury
scopy?
typ wskaźników na funkcje <- fn(type, ...)->type

skończyc parsowanie expression <- dodanie operacji modulo
refacotorowac parsowanie ciala struktury
wyznaczyc typy podstawowe (uint8-64, int8-64, float64-256, chaaaar??? )


    Może warto zaimplementować jumpy i labele i transpilacje?
    Przykład transpilacji poniżej

    // todo do zapytania

    Może niech parser robi to od razu?
    Niech nie ma noda fora tylko noda while i przy parsowaniu fora stworzymy whila?


    ? for <- serio? (dałoby się to zrobić jako whila? )

    for(init_expr; cond; step_expr) {
        body;
    }

    VVVVVVVVVVVV


    {
        init_expr;
        while cond {
            body;
            step_expr;
        }
    }

    ? todo do zapytania
    ? Jakbyśmy mieli etykiety i goto to: (np. label ident; i jump ident;)
    to można zrobić whila jako ifa i jumpa

    while cond {
        body
    }

    VVVVVVVVVVVVVVVVVVVVV

    {
        label while;
        if cond {
            body;
            jump while;
        }
    }


    throw, catch? <- eeeeee?